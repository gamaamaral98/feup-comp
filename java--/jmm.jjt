options {
    LOOKAHEAD=3;
    MULTI=true;
    FORCE_LA_CHECK=true;
}

PARSER_BEGIN(jmm)

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;

public class jmm{

    private static jmm parser;
    private static int optRN = -1;
    private static boolean optO = false;
    

    public static void main(String args []) throws ParseException, IOException{


        // FileInputStream fileStream = openFile(args[0]);
        // if(fileStream == null){
        //     System.out.println("File not found!");
        //     return;
        // }

        // jmm parser = new jmm(fileStream);
        if(readArgs(args) == false){
            return;
        }

        SimpleNode node = parser.Program();
        node.dump("");
    }

    public static FileInputStream openFile(String filename){
        File file = new File(filename);
            
        FileInputStream fileStream;
        try {
            fileStream = new FileInputStream(file);
            return fileStream;
        } catch (FileNotFoundException e) {
            System.out.println("Error in file stream constructor: ");
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            e.printStackTrace();
            return null;
        }
    }

    public static boolean readArgs(String args[]){
        if(args.length < 1){
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            return false;
        }

        FileInputStream fileStream = openFile(args[0]);
        if(fileStream == null){
            System.out.println("File not found!");
            return false;
        }
        parser = new jmm(fileStream);

        for(int i = 1; i < args.length; i++){
            if(validArgs(args[i]) == false)
                return false;
        }
        return true;
    }

    public static boolean validArgs(String arg){
        if(arg.equals("-o")) { 
            if(optO) {
                System.out.println("Error: Option O has already been defined.");
                System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                return false;
            }
            optO = true;
        }
        else if(arg.substring(0, 3).equals("-r=")) {
            if(optRN >= 0) {
                System.out.println("Error: Option R has already been defined.");
                System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                return false;
            }
            if(arg.substring(3).matches("[0-9]+")) {
                optRN = Integer.parseInt(arg.substring(3));
                if(optRN < 0) {
                    System.out.println("Error: The number in option R must be an integer greater or equal to 0.");
                    System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                    return false;
                }
            }
            else {
                System.out.println("Error: The number in option R must be an integer.");
                System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                return false;
            }
        }
        else {
            System.out.println("Error: Non valid argument");
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            return false;
        }
        return true;	
    }
}

PARSER_END(jmm)

SKIP :
{
    " " | "\t" | "\n" | "\r"
    /* Comments */
    | < "//" (~["\r", "\n"])* >
    | < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >
}

TOKEN :
{
  < OP :
      "&&"
    | "<"
    | "+"
    | "-"
    | "*"
    | "/" >
| < NOT_OP : "!" >
| < WHILE : "while" >
| < IF : "if" >
| < ELSE : "else" >
| < ASSIGN : "=" >
| < ASPA : "\"" >
| < LPAR : "(" >
| < RPAR : ")" >
| < DOT : "." >
| < LENGTH : "length" >
| < VIRG : "," >
| < PVIRG : ";" >
| < LCHAVETA : "{" >
| < RCHAVETA : "}" >
| < LPARRETO : "[" >
| < RPARRETO : "]" >
| < EXTENDS : "extends" >
| < CLASS : "class" >
| < PUBLIC : "public" >
| < STATIC : "static" >
| < VOID : "void" >
| < MAIN : "main" >
| < INT : "int" >
| < BOOLEAN : "boolean" >
| < TRUE : "true" >
| < FALSE : "false" >
| < RETURN : "return" >
| < THIS : "this" >
| < NEW : "new" >
| < STRING : "String" >
}

TOKEN :
{
  < INTEGER : (<DIGIT>)+ >
| < IDENTIFIER : <LETTER> (<ALPHANUM>)* >

| < #LETTER : [ "$", "A"-"Z", "_", "a"-"z" ] >
| < #DIGIT : [ "0"-"9" ] >
| < #ALPHANUM : <LETTER> | <DIGIT> >
| < STRING_ASPAS : "\"" ([ "a"-"z", "A"-"Z", "0"-"9", ":", " ", "=" ])+ "\"" >
}



SimpleNode Program() : {}
{
    ClassDeclaration(){
        return jjtThis;
    }
}

void ClassDeclaration() : {}
{
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <LCHAVETA> (
        VarDeclaration()
    )* (
        MainDeclaration()
        | MethodDeclaration()
    )* <RCHAVETA>
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> <PVIRG>
}

void MainDeclaration() : {}
{
    <PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LPARRETO> <RPARRETO> <IDENTIFIER>
    <RPAR> <LCHAVETA> (VarDeclaration())* (Statement())* <RCHAVETA>
}

void MethodDeclaration() : {}
{
    <PUBLIC> Type() <IDENTIFIER> <LPAR> (
        Type() <IDENTIFIER> (
            <VIRG> Type() <IDENTIFIER>
        )*
    )? <RPAR> <LCHAVETA> (
        VarDeclaration()
    )* (
        Statement()
    )* <RETURN> Expression() <PVIRG> <RCHAVETA>
}

void Type() : {}
{
    (<INT> <LCHAVETA> <RCHAVETA>)
    | <BOOLEAN>
    | <INT>
    | <IDENTIFIER>
}

void Statement() : {}
{
    <LCHAVETA> (Statement())* <RCHAVETA>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR> Expression() <RPAR> Statement()
    | Expression() <PVIRG>
    | <IDENTIFIER> <ASSIGN> Expression() <PVIRG>
    | <IDENTIFIER> <LPARRETO> Expression() <RPARRETO> <ASSIGN> Expression() <PVIRG>
}

void Expression() : {}
{
    Expression1() (Expression2())?
}

void Expression1() : {}
{
    <INTEGER>
    | <TRUE>
    | <FALSE>
    | <IDENTIFIER>
    | <THIS>
    | <NEW> <INT> <LPARRETO> Expression() <RPARRETO>
    | <NEW> <IDENTIFIER> <LPAR> <RPAR>
    | <NOT_OP> Expression()
    | <LPAR> Expression() <RPAR>
}

void Expression2() : {}
{
    <OP> Expression()
    | <LPARRETO> Expression() <RPARRETO>
    | <DOT> <LENGTH>
    | <DOT> <IDENTIFIER> <LPAR> (
        Expression() (
            <VIRG> Expression()
        )*
    )? <RPAR>
}
