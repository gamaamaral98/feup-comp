options {
    LOOKAHEAD=2;
    MULTI=true;
    FORCE_LA_CHECK=true;
    //DEBUG_LOOKAHEAD=true;
}

PARSER_BEGIN(jmm)

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;

public class jmm{

    private static jmm parser;
    private static int optRN = -1;
    private static boolean optO = false;
    

    public static void main(String args []) throws ParseException, IOException{

        if(readArgs(args) == false){
            return;
        }

        SimpleNode node = parser.Program();
        node.dump("");
    }

    public static FileInputStream openFile(String filename){
        File file = new File(filename);
            
        FileInputStream fileStream;
        try {
            fileStream = new FileInputStream(file);
            return fileStream;
        } catch (FileNotFoundException e) {
            System.out.println("Error in file stream constructor: ");
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            e.printStackTrace();
            return null;
        }
    }

    public static boolean readArgs(String args[]){
        if(args.length < 1){
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            return false;
        }

        FileInputStream fileStream = openFile(args[0]);
        if(fileStream == null){
            System.out.println("File not found!");
            return false;
        }
        parser = new jmm(fileStream);

        for(int i = 1; i < args.length; i++){
            if(validArgs(args[i]) == false)
                return false;
        }
        return true;
    }

    public static boolean validArgs(String arg){
        if(arg.equals("-o")) { 
            if(optO) {
                System.out.println("Error: Option O has already been defined.");
                System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                return false;
            }
            optO = true;
        }
        else if(arg.length() < 3){
            System.out.println("Error: Non valid argument");
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            return false;
        }
        else if(arg.substring(0, 3).equals("-r=")) {
            if(optRN >= 0) {
                System.out.println("Error: Option R has already been defined.");
                System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                return false;
            }
            if(arg.substring(3).matches("[0-9]+")) {
                optRN = Integer.parseInt(arg.substring(3));
                if(optRN < 0) {
                    System.out.println("Error: The number in option R must be an integer greater or equal to 0.");
                    System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                    return false;
                }
            }
            else {
                System.out.println("Error: The number in option R must be an integer.");
                System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                return false;
            }
        }
        else {
            System.out.println("Error: Non valid argument");
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            return false;
        }
        return true;	
    }
}

PARSER_END(jmm)

SKIP :
{
    " " | "\t" | "\n" | "\r"
    /* Comments */
    | < "//" (~["\r", "\n"])* >
    | < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >
}

TOKEN :
{
< AND_OP : "&&" >
| < LT_OP : "<" >
| < PLUS_OP : "+" >
| < MINUS_OP : "-" >
| < TIMES_OP : "*" >
| < DIVIDE_OP : "/" >
| < NOT_OP : "!" >
| < WHILE : "while" >
| < IF : "if" >
| < ELSE : "else" >
| < ASSIGN : "=" >
| < ASPA : "\"" >
| < LPAR : "(" >
| < RPAR : ")" >
| < DOT : "." >
| < LENGTH : "length" >
| < VIRG : "," >
| < PVIRG : ";" >
| < LCHAVETA : "{" >
| < RCHAVETA : "}" >
| < LPARRETO : "[" >
| < RPARRETO : "]" >
| < EXTENDS : "extends" >
| < CLASS : "class" >
| < PUBLIC : "public" >
| < STATIC : "static" >
| < VOID : "void" >
| < MAIN : "main" >
| < INT : "int" >
| < BOOLEAN : "boolean" >
| < TRUE : "true" >
| < FALSE : "false" >
| < RETURN : "return" >
| < THIS : "this" >
| < NEW : "new" >
| < STRING : "String" >
}

TOKEN :
{
  < INTEGER : (<DIGIT>)+ >
| < IDENTIFIER : <LETTER> (<ALPHANUM>)* >

| < #LETTER : [ "$", "A"-"Z", "_", "a"-"z" ] >
| < #DIGIT : [ "0"-"9" ] >
| < #ALPHANUM : <LETTER> | <DIGIT> >
| < STRING_ASPAS : "\"" ([ "a"-"z", "A"-"Z", "0"-"9", ":", " ", "=" ])+ "\"" >
}

SimpleNode Program() : {}
{
    Expression(){
        return jjtThis;
    }
}

void ClassDeclaration() : {}
{
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <LCHAVETA>
    ( VarDeclaration() )*
    ( <PUBLIC> ClassDeclaration_1() )*
    <RCHAVETA>
}

void ClassDeclaration_1() : {}
{
    MainDeclaration()
    | MethodDeclaration()
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> <PVIRG>
}

void MainDeclaration() : {}
{
    <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LPARRETO> <RPARRETO> <IDENTIFIER>
    <RPAR> <LCHAVETA> (VarDeclaration())* (Statement())* <RCHAVETA>
}

void MethodDeclaration() : {}
{
    Type() <IDENTIFIER> <LPAR>
    (Type() <IDENTIFIER> 
        ( <VIRG> Type() <IDENTIFIER> )*
    )?
    <RPAR> <LCHAVETA>
    ( VarDeclaration() )*
    ( Statement() )*
    <RETURN> Expression() <PVIRG> <RCHAVETA>
}

void Type() : {}
{
    <INT> (<LPARRETO> <RPARRETO>)?
    | <BOOLEAN>
    | <IDENTIFIER>
}

void Statement() : {}
{
    <LCHAVETA> (Statement())* <RCHAVETA>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR> Expression() <RPAR> Statement()
    // | Expression() <PVIRG>
    // | <IDENTIFIER> Statement1() <PVIRG>

    | <IDENTIFIER> Statement1() <PVIRG>
}

void Statement1() : {}
{
    Expression_No_Identifier()
    | Statement2()
}

void Statement2() : {}
{
    <ASSIGN> Expression() #ASSIGN(2)
    | <LPARRETO> Expression() <RPARRETO> #ACCESS_ARRAY(1) <ASSIGN> Expression() #ASSIGN(3)
}

void Expression() #void : {}
{
    Expression1() (Operator_1())*
}

void Expression_No_Identifier() #void : {}
{
    Term_Literal() (Operator_4())* (Operator_3())* (Operator_2())* (Operator_1())*
}

void Expression1() #void : {}
{
    Expression2() (Operator_2())*
}

void Expression2() #void : {}
{
    Expression3() (Operator_3())*
}

void Expression3() #void : {}
{
    Term() (Operator_4())*
}

void Term() #void : {}
{
    Term_Literal()
    | Term_Identifier()
}

void Term_Literal() #void : {}
{
     <INTEGER> #INT(0) (Operator_5())*
    | <TRUE> #TRUE(0) (Operator_5())*
    | <FALSE> #FALSE(0) (Operator_5())*
    | <THIS> #THIS(0) (Operator_5())*
    | <LPAR> Expression() <RPAR> (Operator_5())*
    | Term_NEW() (Operator_5())*
    | Term_NOT()
}

void Term_Identifier() #void : {}
{
    <IDENTIFIER> #IDENTIFIER(0) (Operator_5())*
}

void Term_NOT() #void : {}
{
    <NOT_OP> Term() #NOT(1)
}

void Term_NEW() #void : {}
{
    <NEW> Term_NEW_1()
}

void Term_NEW_1() #void : {}
{
    <INT> <LPARRETO> Expression() <RPARRETO> #NEW_INT_ARRAY(1)
    | <IDENTIFIER> #CLASS <LPAR> <RPAR> #NEW_CLASS(1)
}

void Operator_1() #void : {}
{
    <AND_OP> Expression1() #AND(2)
}

void Operator_2() #void : {}
{
    <LT_OP> Expression2() #LT(2)
}

void Operator_3() #void : {}
{
    <PLUS_OP> Expression3() #ADD(2)
    | <MINUS_OP> Expression3() #SUB(2)
}

void Operator_4() #void : {}
{
    <TIMES_OP> Term() #MUL(2)
    | <DIVIDE_OP> Term() #DIV(2)
}

void Operator_5() #void : {}
{
    <LPARRETO> Expression() <RPARRETO> #ARRAY(2)
    | <DOT> Operator_5_DOT()
}

void Operator_5_DOT() #void : {} {
    <LENGTH> #LENGTH(1)
    | <IDENTIFIER> #FUNCTION <LPAR> Args() <RPAR> #CALL_FUNCTION(3)
}

void Args() #Args : {} {
    (
        Expression() (
            <VIRG> Expression()
        )*
    )?
} 