options {
    LOOKAHEAD=2;
    MULTI=true;
    FORCE_LA_CHECK=true;
}

PARSER_BEGIN(jmm)

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;

public class jmm{

    private static jmm parser;
    private static int optRN = -1;
    private static boolean optO = false;
    

    public static void main(String args []) throws ParseException, IOException{

        if(readArgs(args) == false){
            return;
        }

        SimpleNode node = parser.Program();
        node.dump("");
    }

    public static FileInputStream openFile(String filename){
        File file = new File(filename);
            
        FileInputStream fileStream;
        try {
            fileStream = new FileInputStream(file);
            return fileStream;
        } catch (FileNotFoundException e) {
            System.out.println("Error in file stream constructor: ");
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            e.printStackTrace();
            return null;
        }
    }

    public static boolean readArgs(String args[]){
        if(args.length < 1){
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            return false;
        }

        FileInputStream fileStream = openFile(args[0]);
        if(fileStream == null){
            System.out.println("File not found!");
            return false;
        }
        parser = new jmm(fileStream);

        for(int i = 1; i < args.length; i++){
            if(validArgs(args[i]) == false)
                return false;
        }
        return true;
    }

    public static boolean validArgs(String arg){
        if(arg.equals("-o")) { 
            if(optO) {
                System.out.println("Error: Option O has already been defined.");
                System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                return false;
            }
            optO = true;
        }
        else if(arg.length() < 3){
            System.out.println("Error: Non valid argument");
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            return false;
        }
        else if(arg.substring(0, 3).equals("-r=")) {
            if(optRN >= 0) {
                System.out.println("Error: Option R has already been defined.");
                System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                return false;
            }
            if(arg.substring(3).matches("[0-9]+")) {
                optRN = Integer.parseInt(arg.substring(3));
                if(optRN < 0) {
                    System.out.println("Error: The number in option R must be an integer greater or equal to 0.");
                    System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                    return false;
                }
            }
            else {
                System.out.println("Error: The number in option R must be an integer.");
                System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
                return false;
            }
        }
        else {
            System.out.println("Error: Non valid argument");
            System.out.println("Usage: java -cp bin jmm <filePath> [-r=<n>] [-o]");
            return false;
        }
        return true;	
    }

    public static void error_skipto(ParseException e, String error, int kind) {
        System.out.println("Syntatic Error on " + error + ". " + e.toString());
        Token t;
        do {
            t = getNextToken();
            if(t.kind == EOF)
                break;
        } while (t.kind != kind);
    }
}

PARSER_END(jmm)

SKIP :
{
    " " | "\t" | "\n" | "\r"
    /* Comments */
    | < "//" (~["\r", "\n"])* >
    | < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >
}

TOKEN :
{
    < AND_OP : "&&" >
    | < LT_OP : "<" >
    | < PLUS_OP : "+" >
    | < MINUS_OP : "-" >
    | < TIMES_OP : "*" >
    | < DIVIDE_OP : "/" >
    | < NOT_OP : "!" >
    | < WHILE : "while" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < ASSIGN : "=" >
    | < ASPA : "\"" >
    | < LPAR : "(" >
    | < RPAR : ")" >
    | < DOT : "." >
    | < LENGTH : "length" >
    | < VIRG : "," >
    | < PVIRG : ";" >
    | < LCHAVETA : "{" >
    | < RCHAVETA : "}" >
    | < LPARRETO : "[" >
    | < RPARRETO : "]" >
    | < EXTENDS : "extends" >
    | < CLASS : "class" >
    | < PUBLIC : "public" >
    | < STATIC : "static" >
    | < VOID : "void" >
    | < MAIN : "main" >
    | < INT : "int" >
    | < INT_ARRAY : "int[]" >
    | < BOOLEAN : "boolean" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < RETURN : "return" >
    | < THIS : "this" >
    | < NEW : "new" >
    | < STRING : "String" >
}

TOKEN :
{
    < INTEGER : (<DIGIT>)+ >
    | < IDENTIFIER : <LETTER> (<ALPHANUM>)* >

    | < #LETTER : [ "$", "A"-"Z", "_", "a"-"z" ] >
    | < #DIGIT : [ "0"-"9" ] >
    | < #ALPHANUM : <LETTER> | <DIGIT> >
}

SimpleNode Program() : {}
{
    ClassDeclaration(){
        return jjtThis;
    }
}

void ClassDeclaration() #void : {}
{
    <CLASS> <IDENTIFIER> #CLASS_NAME ClassDeclaration_1()
}

void ClassDeclaration_1() #void : {}
{
    ClassDeclaration_Not_Extends()
    | ClassDeclaration_Extends()   
}

void ClassDeclaration_Not_Extends() #CLASS(3) : {}
{
    <LCHAVETA>
    Vars()
    Methods()
    <RCHAVETA>
}

void ClassDeclaration_Extends() #CLASS_EXTENDS(4) : {}
{
    <EXTENDS> <IDENTIFIER> #EXTENDED_CLASS <LCHAVETA>
    Vars()
    Methods()
    <RCHAVETA>
}

void Vars() #VAR_DECLS : {}
{
    (VarDeclaration())*
}

void Methods() #METHODS : {}
{
    ( <PUBLIC> ClassDeclaration_Methods() )*
}

void Statements() #STATEMENT_LIST : {}
{
    (Statement())*
}

void ClassDeclaration_Methods() #void : {}
{
    MainDeclaration()
    | MethodDeclaration()
}

void VarDeclaration() #VAR_DECL(2) : {}
{
    Type() <IDENTIFIER> #IDENTIFIER <PVIRG>
}

void MainDeclaration() #MAIN(3) : {}
{
    <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LPARRETO> <RPARRETO> <IDENTIFIER> #ARGV
    <RPAR> <LCHAVETA>
    Vars() Statements()
    <RCHAVETA>
}

void MethodDeclaration() #METHOD(6) : {}
{
    Type() <IDENTIFIER> #NAME <LPAR>
    MethodDeclaration_Args()
    <RPAR> <LCHAVETA>
    Vars() Statements()
    <RETURN> Expression() <PVIRG> <RCHAVETA>
}

void MethodDeclaration_Args() #METHOD_ARGS : {}
{
    (
        Type() (<IDENTIFIER> #IDENTIFIER) #ARG(2)
        ( <VIRG> Type() (<IDENTIFIER> #IDENTIFIER) #ARG(2) )*
    )?
}

void Type() #void : {}
{
    <INT> #INT
    | <INT_ARRAY> #INT_ARRAY
    | <BOOLEAN> #BOOLEAN
    | <IDENTIFIER> #IDENTIFIER
}

void Statement() #void : {}
{
    Multiple_Statements()
    | If_Else_Statement()
    | While_Statement()
    | <IDENTIFIER> #IDENTIFIER Statement1() <PVIRG>
}

void Multiple_Statements() #STATEMENT_LIST : {}
{
    <LCHAVETA> (Statement())* <RCHAVETA>
}

void If_Else_Statement() #IF_ELSE(3) : {}
{
    try{
        <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    }catch(ParseException e){
        error_skipto(e, "IF statement", RCHAVETA);
    }
}

void While_Statement() #WHILE(2) : {}
{
    try{
        <WHILE> <LPAR> Expression() <RPAR>
    }
    catch (ParseException e) {
        error_skipto(e, "WHILE statement declaration", RPAR);
    }
    Statement()

    //TODO:
    //<WHILE> <LPAR> Expression() <RPAR> Statement()
}

void Statement1() #void : {}
{
    Expression_No_Identifier()
    | Operator_5_DOT() (Operator_5())*
    | <ASSIGN> Expression() #ASSIGN(2)
    | <LPARRETO> Expression() <RPARRETO> #ACCESS_ARRAY(2) Statement2() 
}

void Statement2() #void : {}
{
    <ASSIGN> Expression() #ASSIGN_ARRAY(2)
    | (Operator_5())*
}

void Expression() #void : {}
{
    Expression1() (Operator_1())*
}

void Expression_No_Identifier() #void : {}
{
    Term_Literal() (Operator_4())* (Operator_3())* (Operator_2())* (Operator_1())*
}

void Expression1() #void : {}
{
    Expression2() (Operator_2())*
}

void Expression2() #void : {}
{
    Expression3() (Operator_3())*
}

void Expression3() #void : {}
{
    Term() (Operator_4())*
}

void Term() #void : {}
{
    Term_Literal()
    | Term_Identifier()
}

void Term_Literal() #void : {}
{
     <INTEGER> #INT(0) (Operator_5())*
    | <TRUE> #TRUE(0) (Operator_5())*
    | <FALSE> #FALSE(0) (Operator_5())*
    | <THIS> #THIS(0) (Operator_5())*
    | <LPAR> Expression() <RPAR> (Operator_5())*
    | Term_NEW() (Operator_5())*
    | Term_NOT()
}

void Term_Identifier() #void : {}
{
    <IDENTIFIER> #IDENTIFIER(0) (Operator_5())*
}

void Term_NOT() #NOT(1) : {}
{
    <NOT_OP> Term()
}

void Term_NEW() #void : {}
{
    <NEW> Term_NEW_1()
}

void Term_NEW_1() #void : {}
{
    <INT> <LPARRETO> Expression() <RPARRETO> #NEW_INT_ARRAY(1)
    | <IDENTIFIER> #CLASS <LPAR> <RPAR> #NEW_CLASS(1)
}

void Operator_1() #AND(2) : {}
{
    <AND_OP> Expression1()
}

void Operator_2() #LT(2) : {}
{
    <LT_OP> Expression2()
}

void Operator_3() #void : {}
{
    <PLUS_OP> Expression3() #ADD(2)
    | <MINUS_OP> Expression3() #SUB(2)
}

void Operator_4() #void : {}
{
    <TIMES_OP> Term() #MUL(2)
    | <DIVIDE_OP> Term() #DIV(2)
}

void Operator_5() #void : {}
{
    Operator_5_ARRAY()
    | Operator_5_DOT()
}

void Operator_5_ARRAY() #ACCESS_ARRAY(2) : {}
{
    <LPARRETO> Expression() <RPARRETO>
}

void Operator_5_DOT() #void : {}
{
    <DOT> Operator_5_DOT_1()
}

void Operator_5_DOT_1() #void : {}
{
    <LENGTH> #LENGTH(1)
    | <IDENTIFIER> #FUNCTION <LPAR> Operator_5_Call_Args() <RPAR> #CALL_FUNCTION(3)
}

void Operator_5_Call_Args() #CALL_ARGUMENTS : {}
{
    (
        Expression() (
            <VIRG> Expression()
        )*
    )?
} 