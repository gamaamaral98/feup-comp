/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. jmm.jj */
/*@egen*/
PARSER_BEGIN(Jmm)

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;


public class Jmm/*@bgen(jjtree)*/implements JmmTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTJmmState jjtree = new JJTJmmState();

/*@egen*/
    public static void main(String args []) throws ParseException, IOException{
        Jmm parser = new Jmm(System.in);
        parser.Aritm();
    }
}

PARSER_END(Jmm)

// Symbols that must be skipped during the lexical analysis
SKIP :
{
" " | "\t" | "\r"
}
// token definition (terminal symbols)
TOKEN :
{
< INTEGER : (["0" - "9"])+ >
| < LF : "\n" >
}

void Aritm() : {/*@bgen(jjtree) Aritm */
                SimpleNode jjtn000 = new SimpleNode(JJTARITM);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}
{/*@bgen(jjtree) Aritm */
try {
/*@egen*/
t1=<INTEGER> {
System.out.println("Integer = "+t1.image);
}
( ("+" | "-") t2=<INTEGER> {
System.out.println("Integer = "+t2.image);
}
)? (<LF>)/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}